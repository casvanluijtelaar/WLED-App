// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'device_list_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$DeviceListEventTearOff {
  const _$DeviceListEventTearOff();

  Initial initial() {
    return const Initial();
  }

  DevicePressed devicePressed(WledDevice device) {
    return DevicePressed(
      device,
    );
  }

  DevicePower devicePower(WledDevice device) {
    return DevicePower(
      device,
    );
  }

  DeviceSlider deviceSlider(WledDevice device, int value) {
    return DeviceSlider(
      device,
      value,
    );
  }

  DeviceAdd deviceAdd(BuildContext context) {
    return DeviceAdd(
      context,
    );
  }

  ListPeriodic listPeriodic() {
    return const ListPeriodic();
  }
}

/// @nodoc
const $DeviceListEvent = _$DeviceListEventTearOff();

/// @nodoc
mixin _$DeviceListEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(WledDevice device) devicePressed,
    required TResult Function(WledDevice device) devicePower,
    required TResult Function(WledDevice device, int value) deviceSlider,
    required TResult Function(BuildContext context) deviceAdd,
    required TResult Function() listPeriodic,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(WledDevice device)? devicePressed,
    TResult Function(WledDevice device)? devicePower,
    TResult Function(WledDevice device, int value)? deviceSlider,
    TResult Function(BuildContext context)? deviceAdd,
    TResult Function()? listPeriodic,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(WledDevice device)? devicePressed,
    TResult Function(WledDevice device)? devicePower,
    TResult Function(WledDevice device, int value)? deviceSlider,
    TResult Function(BuildContext context)? deviceAdd,
    TResult Function()? listPeriodic,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(DevicePressed value) devicePressed,
    required TResult Function(DevicePower value) devicePower,
    required TResult Function(DeviceSlider value) deviceSlider,
    required TResult Function(DeviceAdd value) deviceAdd,
    required TResult Function(ListPeriodic value) listPeriodic,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(DevicePressed value)? devicePressed,
    TResult Function(DevicePower value)? devicePower,
    TResult Function(DeviceSlider value)? deviceSlider,
    TResult Function(DeviceAdd value)? deviceAdd,
    TResult Function(ListPeriodic value)? listPeriodic,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(DevicePressed value)? devicePressed,
    TResult Function(DevicePower value)? devicePower,
    TResult Function(DeviceSlider value)? deviceSlider,
    TResult Function(DeviceAdd value)? deviceAdd,
    TResult Function(ListPeriodic value)? listPeriodic,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeviceListEventCopyWith<$Res> {
  factory $DeviceListEventCopyWith(
          DeviceListEvent value, $Res Function(DeviceListEvent) then) =
      _$DeviceListEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$DeviceListEventCopyWithImpl<$Res>
    implements $DeviceListEventCopyWith<$Res> {
  _$DeviceListEventCopyWithImpl(this._value, this._then);

  final DeviceListEvent _value;
  // ignore: unused_field
  final $Res Function(DeviceListEvent) _then;
}

/// @nodoc
abstract class $InitialCopyWith<$Res> {
  factory $InitialCopyWith(Initial value, $Res Function(Initial) then) =
      _$InitialCopyWithImpl<$Res>;
}

/// @nodoc
class _$InitialCopyWithImpl<$Res> extends _$DeviceListEventCopyWithImpl<$Res>
    implements $InitialCopyWith<$Res> {
  _$InitialCopyWithImpl(Initial _value, $Res Function(Initial) _then)
      : super(_value, (v) => _then(v as Initial));

  @override
  Initial get _value => super._value as Initial;
}

/// @nodoc

class _$Initial implements Initial {
  const _$Initial();

  @override
  String toString() {
    return 'DeviceListEvent.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(WledDevice device) devicePressed,
    required TResult Function(WledDevice device) devicePower,
    required TResult Function(WledDevice device, int value) deviceSlider,
    required TResult Function(BuildContext context) deviceAdd,
    required TResult Function() listPeriodic,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(WledDevice device)? devicePressed,
    TResult Function(WledDevice device)? devicePower,
    TResult Function(WledDevice device, int value)? deviceSlider,
    TResult Function(BuildContext context)? deviceAdd,
    TResult Function()? listPeriodic,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(WledDevice device)? devicePressed,
    TResult Function(WledDevice device)? devicePower,
    TResult Function(WledDevice device, int value)? deviceSlider,
    TResult Function(BuildContext context)? deviceAdd,
    TResult Function()? listPeriodic,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(DevicePressed value) devicePressed,
    required TResult Function(DevicePower value) devicePower,
    required TResult Function(DeviceSlider value) deviceSlider,
    required TResult Function(DeviceAdd value) deviceAdd,
    required TResult Function(ListPeriodic value) listPeriodic,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(DevicePressed value)? devicePressed,
    TResult Function(DevicePower value)? devicePower,
    TResult Function(DeviceSlider value)? deviceSlider,
    TResult Function(DeviceAdd value)? deviceAdd,
    TResult Function(ListPeriodic value)? listPeriodic,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(DevicePressed value)? devicePressed,
    TResult Function(DevicePower value)? devicePower,
    TResult Function(DeviceSlider value)? deviceSlider,
    TResult Function(DeviceAdd value)? deviceAdd,
    TResult Function(ListPeriodic value)? listPeriodic,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class Initial implements DeviceListEvent {
  const factory Initial() = _$Initial;
}

/// @nodoc
abstract class $DevicePressedCopyWith<$Res> {
  factory $DevicePressedCopyWith(
          DevicePressed value, $Res Function(DevicePressed) then) =
      _$DevicePressedCopyWithImpl<$Res>;
  $Res call({WledDevice device});

  $WledDeviceCopyWith<$Res> get device;
}

/// @nodoc
class _$DevicePressedCopyWithImpl<$Res>
    extends _$DeviceListEventCopyWithImpl<$Res>
    implements $DevicePressedCopyWith<$Res> {
  _$DevicePressedCopyWithImpl(
      DevicePressed _value, $Res Function(DevicePressed) _then)
      : super(_value, (v) => _then(v as DevicePressed));

  @override
  DevicePressed get _value => super._value as DevicePressed;

  @override
  $Res call({
    Object? device = freezed,
  }) {
    return _then(DevicePressed(
      device == freezed
          ? _value.device
          : device // ignore: cast_nullable_to_non_nullable
              as WledDevice,
    ));
  }

  @override
  $WledDeviceCopyWith<$Res> get device {
    return $WledDeviceCopyWith<$Res>(_value.device, (value) {
      return _then(_value.copyWith(device: value));
    });
  }
}

/// @nodoc

class _$DevicePressed implements DevicePressed {
  const _$DevicePressed(this.device);

  @override
  final WledDevice device;

  @override
  String toString() {
    return 'DeviceListEvent.devicePressed(device: $device)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DevicePressed &&
            const DeepCollectionEquality().equals(other.device, device));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(device));

  @JsonKey(ignore: true)
  @override
  $DevicePressedCopyWith<DevicePressed> get copyWith =>
      _$DevicePressedCopyWithImpl<DevicePressed>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(WledDevice device) devicePressed,
    required TResult Function(WledDevice device) devicePower,
    required TResult Function(WledDevice device, int value) deviceSlider,
    required TResult Function(BuildContext context) deviceAdd,
    required TResult Function() listPeriodic,
  }) {
    return devicePressed(device);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(WledDevice device)? devicePressed,
    TResult Function(WledDevice device)? devicePower,
    TResult Function(WledDevice device, int value)? deviceSlider,
    TResult Function(BuildContext context)? deviceAdd,
    TResult Function()? listPeriodic,
  }) {
    return devicePressed?.call(device);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(WledDevice device)? devicePressed,
    TResult Function(WledDevice device)? devicePower,
    TResult Function(WledDevice device, int value)? deviceSlider,
    TResult Function(BuildContext context)? deviceAdd,
    TResult Function()? listPeriodic,
    required TResult orElse(),
  }) {
    if (devicePressed != null) {
      return devicePressed(device);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(DevicePressed value) devicePressed,
    required TResult Function(DevicePower value) devicePower,
    required TResult Function(DeviceSlider value) deviceSlider,
    required TResult Function(DeviceAdd value) deviceAdd,
    required TResult Function(ListPeriodic value) listPeriodic,
  }) {
    return devicePressed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(DevicePressed value)? devicePressed,
    TResult Function(DevicePower value)? devicePower,
    TResult Function(DeviceSlider value)? deviceSlider,
    TResult Function(DeviceAdd value)? deviceAdd,
    TResult Function(ListPeriodic value)? listPeriodic,
  }) {
    return devicePressed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(DevicePressed value)? devicePressed,
    TResult Function(DevicePower value)? devicePower,
    TResult Function(DeviceSlider value)? deviceSlider,
    TResult Function(DeviceAdd value)? deviceAdd,
    TResult Function(ListPeriodic value)? listPeriodic,
    required TResult orElse(),
  }) {
    if (devicePressed != null) {
      return devicePressed(this);
    }
    return orElse();
  }
}

abstract class DevicePressed implements DeviceListEvent {
  const factory DevicePressed(WledDevice device) = _$DevicePressed;

  WledDevice get device;
  @JsonKey(ignore: true)
  $DevicePressedCopyWith<DevicePressed> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DevicePowerCopyWith<$Res> {
  factory $DevicePowerCopyWith(
          DevicePower value, $Res Function(DevicePower) then) =
      _$DevicePowerCopyWithImpl<$Res>;
  $Res call({WledDevice device});

  $WledDeviceCopyWith<$Res> get device;
}

/// @nodoc
class _$DevicePowerCopyWithImpl<$Res>
    extends _$DeviceListEventCopyWithImpl<$Res>
    implements $DevicePowerCopyWith<$Res> {
  _$DevicePowerCopyWithImpl(
      DevicePower _value, $Res Function(DevicePower) _then)
      : super(_value, (v) => _then(v as DevicePower));

  @override
  DevicePower get _value => super._value as DevicePower;

  @override
  $Res call({
    Object? device = freezed,
  }) {
    return _then(DevicePower(
      device == freezed
          ? _value.device
          : device // ignore: cast_nullable_to_non_nullable
              as WledDevice,
    ));
  }

  @override
  $WledDeviceCopyWith<$Res> get device {
    return $WledDeviceCopyWith<$Res>(_value.device, (value) {
      return _then(_value.copyWith(device: value));
    });
  }
}

/// @nodoc

class _$DevicePower implements DevicePower {
  const _$DevicePower(this.device);

  @override
  final WledDevice device;

  @override
  String toString() {
    return 'DeviceListEvent.devicePower(device: $device)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DevicePower &&
            const DeepCollectionEquality().equals(other.device, device));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(device));

  @JsonKey(ignore: true)
  @override
  $DevicePowerCopyWith<DevicePower> get copyWith =>
      _$DevicePowerCopyWithImpl<DevicePower>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(WledDevice device) devicePressed,
    required TResult Function(WledDevice device) devicePower,
    required TResult Function(WledDevice device, int value) deviceSlider,
    required TResult Function(BuildContext context) deviceAdd,
    required TResult Function() listPeriodic,
  }) {
    return devicePower(device);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(WledDevice device)? devicePressed,
    TResult Function(WledDevice device)? devicePower,
    TResult Function(WledDevice device, int value)? deviceSlider,
    TResult Function(BuildContext context)? deviceAdd,
    TResult Function()? listPeriodic,
  }) {
    return devicePower?.call(device);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(WledDevice device)? devicePressed,
    TResult Function(WledDevice device)? devicePower,
    TResult Function(WledDevice device, int value)? deviceSlider,
    TResult Function(BuildContext context)? deviceAdd,
    TResult Function()? listPeriodic,
    required TResult orElse(),
  }) {
    if (devicePower != null) {
      return devicePower(device);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(DevicePressed value) devicePressed,
    required TResult Function(DevicePower value) devicePower,
    required TResult Function(DeviceSlider value) deviceSlider,
    required TResult Function(DeviceAdd value) deviceAdd,
    required TResult Function(ListPeriodic value) listPeriodic,
  }) {
    return devicePower(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(DevicePressed value)? devicePressed,
    TResult Function(DevicePower value)? devicePower,
    TResult Function(DeviceSlider value)? deviceSlider,
    TResult Function(DeviceAdd value)? deviceAdd,
    TResult Function(ListPeriodic value)? listPeriodic,
  }) {
    return devicePower?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(DevicePressed value)? devicePressed,
    TResult Function(DevicePower value)? devicePower,
    TResult Function(DeviceSlider value)? deviceSlider,
    TResult Function(DeviceAdd value)? deviceAdd,
    TResult Function(ListPeriodic value)? listPeriodic,
    required TResult orElse(),
  }) {
    if (devicePower != null) {
      return devicePower(this);
    }
    return orElse();
  }
}

abstract class DevicePower implements DeviceListEvent {
  const factory DevicePower(WledDevice device) = _$DevicePower;

  WledDevice get device;
  @JsonKey(ignore: true)
  $DevicePowerCopyWith<DevicePower> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeviceSliderCopyWith<$Res> {
  factory $DeviceSliderCopyWith(
          DeviceSlider value, $Res Function(DeviceSlider) then) =
      _$DeviceSliderCopyWithImpl<$Res>;
  $Res call({WledDevice device, int value});

  $WledDeviceCopyWith<$Res> get device;
}

/// @nodoc
class _$DeviceSliderCopyWithImpl<$Res>
    extends _$DeviceListEventCopyWithImpl<$Res>
    implements $DeviceSliderCopyWith<$Res> {
  _$DeviceSliderCopyWithImpl(
      DeviceSlider _value, $Res Function(DeviceSlider) _then)
      : super(_value, (v) => _then(v as DeviceSlider));

  @override
  DeviceSlider get _value => super._value as DeviceSlider;

  @override
  $Res call({
    Object? device = freezed,
    Object? value = freezed,
  }) {
    return _then(DeviceSlider(
      device == freezed
          ? _value.device
          : device // ignore: cast_nullable_to_non_nullable
              as WledDevice,
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }

  @override
  $WledDeviceCopyWith<$Res> get device {
    return $WledDeviceCopyWith<$Res>(_value.device, (value) {
      return _then(_value.copyWith(device: value));
    });
  }
}

/// @nodoc

class _$DeviceSlider implements DeviceSlider {
  const _$DeviceSlider(this.device, this.value);

  @override
  final WledDevice device;
  @override
  final int value;

  @override
  String toString() {
    return 'DeviceListEvent.deviceSlider(device: $device, value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DeviceSlider &&
            const DeepCollectionEquality().equals(other.device, device) &&
            const DeepCollectionEquality().equals(other.value, value));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(device),
      const DeepCollectionEquality().hash(value));

  @JsonKey(ignore: true)
  @override
  $DeviceSliderCopyWith<DeviceSlider> get copyWith =>
      _$DeviceSliderCopyWithImpl<DeviceSlider>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(WledDevice device) devicePressed,
    required TResult Function(WledDevice device) devicePower,
    required TResult Function(WledDevice device, int value) deviceSlider,
    required TResult Function(BuildContext context) deviceAdd,
    required TResult Function() listPeriodic,
  }) {
    return deviceSlider(device, value);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(WledDevice device)? devicePressed,
    TResult Function(WledDevice device)? devicePower,
    TResult Function(WledDevice device, int value)? deviceSlider,
    TResult Function(BuildContext context)? deviceAdd,
    TResult Function()? listPeriodic,
  }) {
    return deviceSlider?.call(device, value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(WledDevice device)? devicePressed,
    TResult Function(WledDevice device)? devicePower,
    TResult Function(WledDevice device, int value)? deviceSlider,
    TResult Function(BuildContext context)? deviceAdd,
    TResult Function()? listPeriodic,
    required TResult orElse(),
  }) {
    if (deviceSlider != null) {
      return deviceSlider(device, value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(DevicePressed value) devicePressed,
    required TResult Function(DevicePower value) devicePower,
    required TResult Function(DeviceSlider value) deviceSlider,
    required TResult Function(DeviceAdd value) deviceAdd,
    required TResult Function(ListPeriodic value) listPeriodic,
  }) {
    return deviceSlider(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(DevicePressed value)? devicePressed,
    TResult Function(DevicePower value)? devicePower,
    TResult Function(DeviceSlider value)? deviceSlider,
    TResult Function(DeviceAdd value)? deviceAdd,
    TResult Function(ListPeriodic value)? listPeriodic,
  }) {
    return deviceSlider?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(DevicePressed value)? devicePressed,
    TResult Function(DevicePower value)? devicePower,
    TResult Function(DeviceSlider value)? deviceSlider,
    TResult Function(DeviceAdd value)? deviceAdd,
    TResult Function(ListPeriodic value)? listPeriodic,
    required TResult orElse(),
  }) {
    if (deviceSlider != null) {
      return deviceSlider(this);
    }
    return orElse();
  }
}

abstract class DeviceSlider implements DeviceListEvent {
  const factory DeviceSlider(WledDevice device, int value) = _$DeviceSlider;

  WledDevice get device;
  int get value;
  @JsonKey(ignore: true)
  $DeviceSliderCopyWith<DeviceSlider> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeviceAddCopyWith<$Res> {
  factory $DeviceAddCopyWith(DeviceAdd value, $Res Function(DeviceAdd) then) =
      _$DeviceAddCopyWithImpl<$Res>;
  $Res call({BuildContext context});
}

/// @nodoc
class _$DeviceAddCopyWithImpl<$Res> extends _$DeviceListEventCopyWithImpl<$Res>
    implements $DeviceAddCopyWith<$Res> {
  _$DeviceAddCopyWithImpl(DeviceAdd _value, $Res Function(DeviceAdd) _then)
      : super(_value, (v) => _then(v as DeviceAdd));

  @override
  DeviceAdd get _value => super._value as DeviceAdd;

  @override
  $Res call({
    Object? context = freezed,
  }) {
    return _then(DeviceAdd(
      context == freezed
          ? _value.context
          : context // ignore: cast_nullable_to_non_nullable
              as BuildContext,
    ));
  }
}

/// @nodoc

class _$DeviceAdd implements DeviceAdd {
  const _$DeviceAdd(this.context);

  @override
  final BuildContext context;

  @override
  String toString() {
    return 'DeviceListEvent.deviceAdd(context: $context)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is DeviceAdd &&
            const DeepCollectionEquality().equals(other.context, context));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(context));

  @JsonKey(ignore: true)
  @override
  $DeviceAddCopyWith<DeviceAdd> get copyWith =>
      _$DeviceAddCopyWithImpl<DeviceAdd>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(WledDevice device) devicePressed,
    required TResult Function(WledDevice device) devicePower,
    required TResult Function(WledDevice device, int value) deviceSlider,
    required TResult Function(BuildContext context) deviceAdd,
    required TResult Function() listPeriodic,
  }) {
    return deviceAdd(context);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(WledDevice device)? devicePressed,
    TResult Function(WledDevice device)? devicePower,
    TResult Function(WledDevice device, int value)? deviceSlider,
    TResult Function(BuildContext context)? deviceAdd,
    TResult Function()? listPeriodic,
  }) {
    return deviceAdd?.call(context);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(WledDevice device)? devicePressed,
    TResult Function(WledDevice device)? devicePower,
    TResult Function(WledDevice device, int value)? deviceSlider,
    TResult Function(BuildContext context)? deviceAdd,
    TResult Function()? listPeriodic,
    required TResult orElse(),
  }) {
    if (deviceAdd != null) {
      return deviceAdd(context);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(DevicePressed value) devicePressed,
    required TResult Function(DevicePower value) devicePower,
    required TResult Function(DeviceSlider value) deviceSlider,
    required TResult Function(DeviceAdd value) deviceAdd,
    required TResult Function(ListPeriodic value) listPeriodic,
  }) {
    return deviceAdd(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(DevicePressed value)? devicePressed,
    TResult Function(DevicePower value)? devicePower,
    TResult Function(DeviceSlider value)? deviceSlider,
    TResult Function(DeviceAdd value)? deviceAdd,
    TResult Function(ListPeriodic value)? listPeriodic,
  }) {
    return deviceAdd?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(DevicePressed value)? devicePressed,
    TResult Function(DevicePower value)? devicePower,
    TResult Function(DeviceSlider value)? deviceSlider,
    TResult Function(DeviceAdd value)? deviceAdd,
    TResult Function(ListPeriodic value)? listPeriodic,
    required TResult orElse(),
  }) {
    if (deviceAdd != null) {
      return deviceAdd(this);
    }
    return orElse();
  }
}

abstract class DeviceAdd implements DeviceListEvent {
  const factory DeviceAdd(BuildContext context) = _$DeviceAdd;

  BuildContext get context;
  @JsonKey(ignore: true)
  $DeviceAddCopyWith<DeviceAdd> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ListPeriodicCopyWith<$Res> {
  factory $ListPeriodicCopyWith(
          ListPeriodic value, $Res Function(ListPeriodic) then) =
      _$ListPeriodicCopyWithImpl<$Res>;
}

/// @nodoc
class _$ListPeriodicCopyWithImpl<$Res>
    extends _$DeviceListEventCopyWithImpl<$Res>
    implements $ListPeriodicCopyWith<$Res> {
  _$ListPeriodicCopyWithImpl(
      ListPeriodic _value, $Res Function(ListPeriodic) _then)
      : super(_value, (v) => _then(v as ListPeriodic));

  @override
  ListPeriodic get _value => super._value as ListPeriodic;
}

/// @nodoc

class _$ListPeriodic implements ListPeriodic {
  const _$ListPeriodic();

  @override
  String toString() {
    return 'DeviceListEvent.listPeriodic()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is ListPeriodic);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function(WledDevice device) devicePressed,
    required TResult Function(WledDevice device) devicePower,
    required TResult Function(WledDevice device, int value) deviceSlider,
    required TResult Function(BuildContext context) deviceAdd,
    required TResult Function() listPeriodic,
  }) {
    return listPeriodic();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(WledDevice device)? devicePressed,
    TResult Function(WledDevice device)? devicePower,
    TResult Function(WledDevice device, int value)? deviceSlider,
    TResult Function(BuildContext context)? deviceAdd,
    TResult Function()? listPeriodic,
  }) {
    return listPeriodic?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function(WledDevice device)? devicePressed,
    TResult Function(WledDevice device)? devicePower,
    TResult Function(WledDevice device, int value)? deviceSlider,
    TResult Function(BuildContext context)? deviceAdd,
    TResult Function()? listPeriodic,
    required TResult orElse(),
  }) {
    if (listPeriodic != null) {
      return listPeriodic();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Initial value) initial,
    required TResult Function(DevicePressed value) devicePressed,
    required TResult Function(DevicePower value) devicePower,
    required TResult Function(DeviceSlider value) deviceSlider,
    required TResult Function(DeviceAdd value) deviceAdd,
    required TResult Function(ListPeriodic value) listPeriodic,
  }) {
    return listPeriodic(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(DevicePressed value)? devicePressed,
    TResult Function(DevicePower value)? devicePower,
    TResult Function(DeviceSlider value)? deviceSlider,
    TResult Function(DeviceAdd value)? deviceAdd,
    TResult Function(ListPeriodic value)? listPeriodic,
  }) {
    return listPeriodic?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Initial value)? initial,
    TResult Function(DevicePressed value)? devicePressed,
    TResult Function(DevicePower value)? devicePower,
    TResult Function(DeviceSlider value)? deviceSlider,
    TResult Function(DeviceAdd value)? deviceAdd,
    TResult Function(ListPeriodic value)? listPeriodic,
    required TResult orElse(),
  }) {
    if (listPeriodic != null) {
      return listPeriodic(this);
    }
    return orElse();
  }
}

abstract class ListPeriodic implements DeviceListEvent {
  const factory ListPeriodic() = _$ListPeriodic;
}

/// @nodoc
class _$DeviceListStateTearOff {
  const _$DeviceListStateTearOff();

  Loading loading() {
    return const Loading();
  }

  Found found(List<WledDevice> devices) {
    return Found(
      devices,
    );
  }

  Empty empty() {
    return const Empty();
  }
}

/// @nodoc
const $DeviceListState = _$DeviceListStateTearOff();

/// @nodoc
mixin _$DeviceListState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(List<WledDevice> devices) found,
    required TResult Function() empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<WledDevice> devices)? found,
    TResult Function()? empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<WledDevice> devices)? found,
    TResult Function()? empty,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Loading value) loading,
    required TResult Function(Found value) found,
    required TResult Function(Empty value) empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Loading value)? loading,
    TResult Function(Found value)? found,
    TResult Function(Empty value)? empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Loading value)? loading,
    TResult Function(Found value)? found,
    TResult Function(Empty value)? empty,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeviceListStateCopyWith<$Res> {
  factory $DeviceListStateCopyWith(
          DeviceListState value, $Res Function(DeviceListState) then) =
      _$DeviceListStateCopyWithImpl<$Res>;
}

/// @nodoc
class _$DeviceListStateCopyWithImpl<$Res>
    implements $DeviceListStateCopyWith<$Res> {
  _$DeviceListStateCopyWithImpl(this._value, this._then);

  final DeviceListState _value;
  // ignore: unused_field
  final $Res Function(DeviceListState) _then;
}

/// @nodoc
abstract class $LoadingCopyWith<$Res> {
  factory $LoadingCopyWith(Loading value, $Res Function(Loading) then) =
      _$LoadingCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoadingCopyWithImpl<$Res> extends _$DeviceListStateCopyWithImpl<$Res>
    implements $LoadingCopyWith<$Res> {
  _$LoadingCopyWithImpl(Loading _value, $Res Function(Loading) _then)
      : super(_value, (v) => _then(v as Loading));

  @override
  Loading get _value => super._value as Loading;
}

/// @nodoc

class _$Loading implements Loading {
  const _$Loading();

  @override
  String toString() {
    return 'DeviceListState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Loading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(List<WledDevice> devices) found,
    required TResult Function() empty,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<WledDevice> devices)? found,
    TResult Function()? empty,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<WledDevice> devices)? found,
    TResult Function()? empty,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Loading value) loading,
    required TResult Function(Found value) found,
    required TResult Function(Empty value) empty,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Loading value)? loading,
    TResult Function(Found value)? found,
    TResult Function(Empty value)? empty,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Loading value)? loading,
    TResult Function(Found value)? found,
    TResult Function(Empty value)? empty,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class Loading implements DeviceListState {
  const factory Loading() = _$Loading;
}

/// @nodoc
abstract class $FoundCopyWith<$Res> {
  factory $FoundCopyWith(Found value, $Res Function(Found) then) =
      _$FoundCopyWithImpl<$Res>;
  $Res call({List<WledDevice> devices});
}

/// @nodoc
class _$FoundCopyWithImpl<$Res> extends _$DeviceListStateCopyWithImpl<$Res>
    implements $FoundCopyWith<$Res> {
  _$FoundCopyWithImpl(Found _value, $Res Function(Found) _then)
      : super(_value, (v) => _then(v as Found));

  @override
  Found get _value => super._value as Found;

  @override
  $Res call({
    Object? devices = freezed,
  }) {
    return _then(Found(
      devices == freezed
          ? _value.devices
          : devices // ignore: cast_nullable_to_non_nullable
              as List<WledDevice>,
    ));
  }
}

/// @nodoc

class _$Found implements Found {
  const _$Found(this.devices);

  @override
  final List<WledDevice> devices;

  @override
  String toString() {
    return 'DeviceListState.found(devices: $devices)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Found &&
            const DeepCollectionEquality().equals(other.devices, devices));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(devices));

  @JsonKey(ignore: true)
  @override
  $FoundCopyWith<Found> get copyWith =>
      _$FoundCopyWithImpl<Found>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(List<WledDevice> devices) found,
    required TResult Function() empty,
  }) {
    return found(devices);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<WledDevice> devices)? found,
    TResult Function()? empty,
  }) {
    return found?.call(devices);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<WledDevice> devices)? found,
    TResult Function()? empty,
    required TResult orElse(),
  }) {
    if (found != null) {
      return found(devices);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Loading value) loading,
    required TResult Function(Found value) found,
    required TResult Function(Empty value) empty,
  }) {
    return found(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Loading value)? loading,
    TResult Function(Found value)? found,
    TResult Function(Empty value)? empty,
  }) {
    return found?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Loading value)? loading,
    TResult Function(Found value)? found,
    TResult Function(Empty value)? empty,
    required TResult orElse(),
  }) {
    if (found != null) {
      return found(this);
    }
    return orElse();
  }
}

abstract class Found implements DeviceListState {
  const factory Found(List<WledDevice> devices) = _$Found;

  List<WledDevice> get devices;
  @JsonKey(ignore: true)
  $FoundCopyWith<Found> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EmptyCopyWith<$Res> {
  factory $EmptyCopyWith(Empty value, $Res Function(Empty) then) =
      _$EmptyCopyWithImpl<$Res>;
}

/// @nodoc
class _$EmptyCopyWithImpl<$Res> extends _$DeviceListStateCopyWithImpl<$Res>
    implements $EmptyCopyWith<$Res> {
  _$EmptyCopyWithImpl(Empty _value, $Res Function(Empty) _then)
      : super(_value, (v) => _then(v as Empty));

  @override
  Empty get _value => super._value as Empty;
}

/// @nodoc

class _$Empty implements Empty {
  const _$Empty();

  @override
  String toString() {
    return 'DeviceListState.empty()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is Empty);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(List<WledDevice> devices) found,
    required TResult Function() empty,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<WledDevice> devices)? found,
    TResult Function()? empty,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(List<WledDevice> devices)? found,
    TResult Function()? empty,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Loading value) loading,
    required TResult Function(Found value) found,
    required TResult Function(Empty value) empty,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Loading value)? loading,
    TResult Function(Found value)? found,
    TResult Function(Empty value)? empty,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Loading value)? loading,
    TResult Function(Found value)? found,
    TResult Function(Empty value)? empty,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class Empty implements DeviceListState {
  const factory Empty() = _$Empty;
}
